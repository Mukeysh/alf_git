<?php
include_once('scholar_publications.features.inc');

function scholar_publications_init(){

	jquery_ui_add(array('ui.tabs'));
}

/**
 * Implementation of hook_context_links_alter().
 */
function scholar_publications_context_links_alter(&$links) {
  if (! empty ( $links ['biblio'] )) {
    $links ['importbiblio'] = array (
      'title' => 'Import publications',
      'href' => 'publications/import',
      'query' => drupal_get_destination(),
      'custom' => TRUE
    );

    $links['biblio']['query'] = drupal_get_destination();
    $links ['biblio']['title'] = "Add publication";

    $links = array_reverse($links);
  }
}

function scholar_publications_menu(){
  $items["publications"] = array(
    'title' => 'Publications',
    'page callback' => 'scholar_publications_overview',
    'access callback' => 'spaces_access_feature',
    'access arguments' => array('view','scholar_publications'),
    'menu_name' => 'features',
  );

  // import export
  $items['publications/import'] = array(
    'title'             => 'Import',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('biblio_import_form'),
    'file'              => 'biblio.import.export.inc',
    'file path'         => drupal_get_path('module', 'biblio'),
    'access callback'   => 'user_access',
    'access arguments'  => array('import from file'),
    //'type'              => MENU_LOCAL_TASK,
    'type'              => MENU_CALLBACK,
    'weight'            => 10,
  );

  $items['features/scholar_publications'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('scholar_publications_settings'),
    'access callback' => module_exists('spaces') ? 'spaces_access_admin' : 'user_access',
    'access arguments' => module_exists('spaces') ? array() : array('administer site configuration'),
    'type' => MENU_CALLBACK,
    'file' => 'scholar_publications.pages.inc',
  );

  return $items;
}

/**
 * Alter the menu items
 * @param array $items
 */
function scholar_publications_menu_alter(&$items){
  $s_bib_base = variable_get('biblio_base', 'biblio');

  if(array_key_exists("{$s_bib_base}/filter",$items)){
    $items["{$s_bib_base}/filter"]['type'] = MENU_CALLBACK;
  }//Remove the filter local task

  // run exports through our function so we can change filename
  $items[$s_bib_base.'/export']['page callback'] = 'scholar_publications_export';
  $items[$s_bib_base.'/export']['file'] = 'scholar_publications.module';
  $items[$s_bib_base.'/export']['file path'] = drupal_get_path('module', 'scholar_publications');
}

/**
 * hook form_alter
 * Alter the import publications form
 */
function scholar_publications_form_alter(&$form, $form_state, $form_id){

	$show_form_ids = array('content_field_overview_form', 'content_display_overview_form');
  //only show the 'field_biblio_image' field for book or book chapter nodes
  if ($form_id == 'biblio_node_form' && array_key_exists('field_biblio_image',$form) && in_array($form['biblio_type']['#default_value'], array(100,101))){
    $form['field_biblio_image']['#access'] = TRUE; //only show the 'field_biblio_image' field for book or book chapter nodes
  }
  elseif(in_array($form_id, $show_form_ids)){
    $form['field_biblio_image']['#access'] = TRUE;  // show the book cover image field on the content field/display edit forms
  }
  elseif (isset($form['field_biblio_image'])){
    $form['field_biblio_image']['#access'] = FALSE;
  }

  if ($form_id == 'biblio_import_form') {
    // the original form is asking to set the userID for these entries
    // Just the group admin for now. TODO list of users for this og

    //Biblio's input form is way too big
    $form['biblio_import_file'] = array (
      '#type' => 'file',
      '#title' => t('Import file'),
      '#default_value' => '',
      '#size' => ''
    );

    $vsite = vsite_get_vsite();
    //$group_node = og_get_group_context();
    $uid = $vsite->group->uid;
    $form['userid'] = array(
      '#type' => 'value',
      "#value" => $uid
    );
    $form['batch_process'] = array(
      '#type' => 'value',
      "#value" => 1
    );
    $form['filetype']['#type'] = 'radios';
    unset( $form['filetype']['#options']['none']);
    $form['filetype']['#default_value'] = 'bib';
    // just unset the taxonomy settings for now.
    unset($form['import_taxonomy']);
  }
  elseif (isset($form['#node']) && $form['#node']->type === 'biblio' && $form_id == $form['#node']->type .'_node_form') {
  	drupal_add_js(drupal_get_path('module','scholar_publications').'/theme/Drupal.scholarPublications.js');

	  $show_form_ids = array('content_field_overview_form', 'content_display_overview_form');
	  //only show the 'field_biblio_image' field for book or book chapter nodes
	  if ($form_id == 'biblio_node_form' && in_array($form['biblio_type']['#default_value'], array(100,101))){
	    $form['field_biblio_image']['#access'] = TRUE; //only show the 'field_biblio_image' field for book or book chapter nodes
	  }
	  elseif(in_array($form_id, $show_form_ids)){
	    $form['field_biblio_image']['#access'] = TRUE;  // show the book cover image field on the content field/display edit forms
	  }
	  else{
	    $form['field_biblio_image']['#access'] = FALSE;
	    if(isset($form['field_biblio_image'][0])) $form['field_biblio_image'][0]['#access'] = false;
	  }

  	if(!$form_state['storage']['biblio_type'] && !$form['#node']->biblio_type){
  	  scholar_publications_hide_form_value($form['biblio_doi_lookup']);
      scholar_publications_hide_form_value($form['biblio_cut_paste']);
    }

    if(is_array($form['biblio_notes_field']) && is_array($form['biblio_notes_field']['biblio_notes'])){
    	$form['biblio_notes'] = $form['biblio_notes_field']['biblio_notes'];
      unset($form['biblio_notes_field']);

      ctools_include('ajax');
      ctools_include('modal');
      ctools_modal_add_js();
      //Adding to the description in code here since it needs to have a dynamic URL
      $form['biblio_notes']['#description'] .= ' Your notes are currently set to <strong>'.(variable_get('scholar_publication_note_in_teaser',false)?"public":"private").'</strong>. '.ctools_modal_text_button('Change Note Settings.', 'features/nojs/scholar_publications', 'customize publications');
    }

  	if(array_key_exists('other_fields',$form)) scholar_publications_hide_form_value($form['other_fields']);
  	if(array_key_exists('biblio_keywords',$form)){
    	scholar_publications_hide_form_value($form['biblio_keywords']);
    	if(array_key_exists('taxonomy',$form) && array_key_exists('copy_to_biblio',$form['taxonomy'])){
    		$form['taxonomy']['copy_to_biblio']['#default'] = 1;
    		scholar_publications_hide_form_value($form['taxonomy']['copy_to_biblio']);
    	}
    }
    $form['submit_type'] = array('#type' => 'submit', '#disabled' => true, '#access' => false, '#value' => t('Select Publication Type'));

    //update biblio_year's description
    $year = 9998;
    $year_titles = array('YYYY');
    while (($text_year = _biblio_text_year($year)) && $text_year != $year) {
      $year_titles[] = $text_year;
      $year++;
    }
    $year_titles[count($year_titles)-1] = 'or ' . $year_titles[count($year_titles)-1];
    $form['biblio_year']['#description'] = 'Enter ' . implode(', ', $year_titles);

    //authors should always be open
    if(array_key_exists('author',$form)){
      $form['author'] ['#collapsed'] = false;
    }
    if(array_key_exists('contributors1_wrapper',$form)){
      $form['contributors1_wrapper'] ['#collapsed'] = false;
      $form['contributors1_wrapper'] ['#weight'] = -3.5;
    }

    if(array_key_exists('contributors2_wrapper',$form)){
      $form['contributors2_wrapper'] ['#weight'] = -3.5;
    }

    if(array_key_exists('biblio_abst_e_field',$form) && array_key_exists('biblio_abst_e',$form['biblio_abst_e_field'])){
      $form['biblio_abst_e'] = $form['biblio_abst_e_field']['biblio_abst_e'];
      unset($form['biblio_abst_e_field']);
    }//remove fieldset

    $form['biblio_abst_e']['#description'] .= t(' You may use HTML tags to add links, standard formatting elements such as bold and underline, as well as headers, lists, images and tables.');
    $form['biblio_notes']['#description'] .= t(' You may use HTML tags to add links, standard formatting elements such as bold and underline, as well as headers, lists, images and tables.');

    if(is_array($form['taxonomy']) && array_key_exists('copy_to_biblio',$form['taxonomy'])){
      $form['taxonomy']['copy_to_biblio']['#type'] = 'value';
    }

    if(array_key_exists('field_biblio_extra',$form) && is_array($form['field_biblio_extra'])){
      $form['field_biblio_extra']['field_biblio_extra_add_more']['#value'] = 'Add Another Field';
    }
    

      
    if(!$form['#vertical_tabs']) $form['#vertical_tabs'] = array();
    $form['#vertical_tabs']['biblio_abst_e_field'] = 0; //Disable vert. tabs
    $form['#vertical_tabs']['body_field'] = 0; //Disable vert. tabs
    $form['#vertical_tabs']['contributors1_wrapper'] = 0; //Disable vert. tabs
    $form['#vertical_tabs']['contributors2_wrapper'] = 0; //Disable vert. tabs
    $form['#vertical_tabs']['attachments'] = 0; //Disable vert. tabs
    $form['#vertical_tabs']['extra_fields_group'] = 0; //Disable vert. tabs

    if(strlen($form['biblio_type']['#default_value'])){
      $form['extra_fields_group'] = array(
        '#type' => 'fieldset',
        '#title' => t('Publication Extras'),
        '#weight' => 14,
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#tree' => false,
      );
      if(!isset($form['#after_build'])) $form['#after_build'] = array();
      $form['#after_build'][] = 'scholar_publications_move_extras';

      // url/url_title fieldset
      $form['url_fieldset'] = array(
        '#type' => 'fieldset',
        '#title' => t('Related External Link'),
        '#weight' => 14,
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
              '#tree' => false,
      
      );
      $nid = $form['nid']['#value'];
      $url_title = db_result(db_query('SELECT biblio_url_title FROM {biblio} WHERE nid = %d ', (int)$nid));
      $url_title = (isset($url_title) && $url_title) ? $url_title : 'Website';
      
      $form['url_fieldset']['biblio_url_title'] = array(
        '#default_value' 			=> $url_title,
        '#type'               => 'textfield',
        '#title'              => t('Title'),
        '#weight'             => $form['biblio_url']['#weight']+1,
        '#size'								=> $form['biblio_url']['#size'],
        '#description'				=> t('Text to show when linking to external URL.'),
              '#tree' => false,
      
      );
      
      // move biblio_url into the fieldset
      $form['biblio_url']['#title'] = t('URL');
      $form['url_fieldset']['biblio_url'] = $form['biblio_url'];
      unset($form['biblio_url']);
    
    }//If the publication type field has been set

    if (isset($form['format'])) {
      $form['body_field']['format'] = $form['format'];
      unset($form['format']);

      $t = $form['body_field']['teaser_include'];
      unset($form['body_field']['teaser_include']);
      $form['body_field']['teaser_include'] = $t;
    }

    //Remove the sticky option.  Our view ignores it, so we shouldn't mislead users.
    unset( $form['options']['sticky'] );

  }elseif ($form_id == 'biblio_contributors_js') {
  	//Make sure default rank is set correctly in ajax call when form is built
  	if(!isset($form['rank']['#value']) && isset($form['rank']['#default_value'])){
  		$form['rank']['#value'] = $form['rank']['#default_value'];
  	}
  }
}

/**
 * Move some fields within the "Publication Extras" fieldset to clean up the biblio form
 *
 * @param array $form
 * @param array $form_state
 */
function scholar_publications_move_extras($form, &$form_state){
  //The JS Call Expects the field to be in the orig position so we can't move them for the "Add More" callbacks
  if(strpos($_GET['q'],"content/js_add_more") === 0 || strpos($_GET['q'],"filefield/ahah/biblio/field_biblio_image") === 0 ) {
    return $form;
  }

  $a_publication_extras = array('body_field','biblio_notes','biblio_abst_e_field','biblio_abst_e', 'url_fieldset', 'field_biblio_image','field_biblio_extra');

  //Pub url in the main section for some biblio types
  if($form['#id'] == 'biblio_node_form' && in_array($form['biblio_type']['#default_value'], array(125, 113, 107))) unset($a_publication_extras[array_search('url_fieldset',$a_publication_extras)]);

  //Move these form elements into thier own group
  foreach ($a_publication_extras as $n_count => $extra_field){
    if(array_key_exists($extra_field,$form)){
      $form['extra_fields_group'][$extra_field] = $form[$extra_field];
      $form['extra_fields_group'][$extra_field]['#weight'] = $n_count;
      $form['extra_fields_group'][$extra_field]['#collapsed'] = false;
      unset($form[$extra_field]);
    }
  }

  return $form;
}

function scholar_publications_hide_form_value(&$element){
  foreach(element_children($element) as $s_key){
    $element[$s_key]['#type'] = 'value';
    vsite_users_hide_form_value($element[$s_key]);;
  }
  $element['#type'] = 'value';
}

/**
 * Handles the caching for the main publications page which is not a view
 */
function scholar_publications_get_cache($cache_key){
	if(!module_exists('views_content_cache')) return;

  $cutoff = 0;
  $cache_params = array(
    'os_og' => array('current' => 'current'),
  );//Clear when node is saved or settings changed (since order is a biblio setting)

  // Retrieve the latest update time matching the settings on this View.
  $cid = array();
  foreach ($cache_params as $key_id => $key_values) {
    if ($plugin = views_content_cache_get_plugin($key_id)) {
      $cid[$key_id] = $plugin->view_key($key_values);
    }
  }
  if (!empty($cid) && ($timestamp = views_content_cache_update_get($cid))) {
    $cutoff = $timestamp;
  }

  // enforce a maximum lifetime default(1 day)
  if ($n_max = variable_get('scholar_publications_cache_max_lifespan',(3600 * 24))) {
    if ($n_max != -1) {
      $max_lifespan = time() - $n_max;
      $cutoff = max($max_lifespan, $cutoff);
    }
  }

  if (($cache = cache_get($cache_key, 'cache_views_data')) && (!$cutoff || $cache->created > $cutoff)) {
    return $cache->data;
  }

  return false;
}

/**
 * Returns the cache key for the scholar_publications overview page
 */
function scholar_publications_overview_get_cache_key($arguments){
	if($_SERVER['REQUEST_METHOD'] != 'GET') return false;

  //Match biblio's bizare argument mumbo-jumbo
	foreach ($_GET as $key => $value) {
    if ($key != 'q') {
      $arguments[] = check_plain($key);
      $arguments[] = check_plain($value);
    }
  }

  if(array_search('search', $arguments) || _get_biblio_search_filter()){
  	return false;
  }//Don't cache if biblio has it's specal search to execute (rare)

  global $theme, $user;

  $cid_parts = array();

  $vsite = vsite_get_vsite();
  $cid_parts[] = (isset($vsite->group->purl))? $vsite->group->purl:"";
  $cid_parts[] = $theme;
  $cid_parts[] = ($user->uid == 1)?1:0; // special caching for super user.

  //Biblio Arguments
  $cid_parts[] = md5(serialize($arguments));

  if (module_exists('locale')) {
    global $language;
    $cid_parts[] = $language->language;
  }

  return "scholar_publication:results:".implode(':', $cid_parts);
}

/**
 * Main menu entry for the publications page
 */
function scholar_publications_overview(){
	$vsite = vsite_get_vsite();

  //page title = the name of the menu they have in settings or "Publications"
  $page_title = (is_array($vsite->customizer['menu']) && isset($vsite->customizer['menu']['publications'])) ? $vsite->customizer['menu']['publications'] : "Publications";
  variable_set('biblio_base_title', $page_title);

  module_load_include('inc', 'biblio', 'biblio.pages');

  $a_args = func_get_args();
  if(count($a_args)){
	  foreach ($a_args as $k => $arg) {
	    if ($arg == 'type' && !empty($a_args[$k+1])) {
	      // why not use variable_set? cause this change isnt permanent.
	      global $conf;
	      unset($conf['biblio_sort_tabs']['type']);
	
	      $type = $a_args[$k+1];
	      $type = ucwords(str_replace('_', ' ', $type));
	      $type_data = db_fetch_array(db_query("SELECT tid, name FROM {biblio_types} WHERE name = '%s' OR tid = %d", $type, $type));
	      if ($type_data['tid']) {
	        $a_args[$k+1] = $type_data['tid'];
	      }
	    }
	  }
  }elseif (($a_filtered_pubtypes = variable_get('scholar_publications_filter_publication_types',array())) && count($a_filtered_pubtypes)){
  	if($a_filtered_pubtypes != array_keys(scholar_publications_get_biblio_types())){
	  	//Filter pulications to those requested, if they do not have all pub types selected
	  	$a_args = array('type',$a_filtered_pubtypes);
  	}
  }

  if (isset($type_data)) drupal_set_title(check_plain( scholar_publications_get_plural_biblio_type($type_data['name']) ));

  if(($cache_key = scholar_publications_overview_get_cache_key($a_args))
  && ($s_cached = scholar_publications_get_cache($cache_key))){
  	return $s_cached;
  }

  $s_bib_out =  call_user_func_array('biblio_db_search',$a_args);

  global $pager_total_items;
  if(!is_array($pager_total_items) || $pager_total_items[0] <= 0){

	  //Display Empty Result Text
	  $contexts = context_enabled_contexts();
	  $nodetype = null;
	  if(array_key_exists('openscholar-feature-publications',$contexts) && ($context = $contexts["openscholar-feature-publications"])){
	    if (!empty($context->node)) {
	      reset($context->node);
	      $nodetype = current($context->node);
	    }
	  }

	  $s_bib_out = vsite_empty_view_message($nodetype,$vsite);
  }

  if($cache_key){
  	//Permanant Cache, we will clear this manually
    cache_set($cache_key, $s_bib_out, 'cache_views_data', CACHE_PERMANENT);
  }

  return $s_bib_out;
}

/**
 * hoook nodeapi
 */
function scholar_publications_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if ($node -> type != 'biblio') return;
  switch ($op) {
  	case 'load':
  	  $s_orig_text = variable_get('biblio_no_year_text', t('Submitted'));
 		  if($node->biblio_year){
  	  	if($node->biblio_year === $s_orig_text) $node->biblio_year = 9999;
  		  $node->biblio_year = _biblio_text_year($node->biblio_year);
  	  }
  	break;
    case 'presave':

      $vsite = vsite_get_vsite();
      $gid = $vsite -> group -> nid;
      $node -> og_groups = array($gid);

      $node->biblio_notes = check_markup($node->biblio_notes);
      $node->biblio_abst_e = check_markup($node->biblio_abst_e);
      
      //Get numeric biblio year or assume submitted
      if ((int)$node->biblio_year == 0 && $int_year = _biblio_numeric_year($node->biblio_year)) {
        $node->biblio_year = $int_year;
      }

    break;
    case 'update':
      drupal_set_message('publication node updated');
    case 'insert':
    	//Associate biblio authors with site owners
      if(!empty($node->biblio_contributors)){
        $md5 = _loadMD5();
        foreach ($node->biblio_contributors as $cat => $authors) {
          foreach ($authors as $key => $author) {
          	if(!$author['vsite_owner']) continue; //Is this the site owner

            if (empty ($author['cid']) && !empty ($md5)) $author['cid'] = array_search($author['md5'], $md5);
            $vsite = vsite_get_vsite();

            if (empty($author['cid']) || !$author['cid'] || !$vsite) continue; //Do we have the CID

            db_query("UPDATE {biblio_contributor_data} SET drupal_uid = 0 WHERE drupal_uid = %d", $vsite->group->uid);
            db_query('UPDATE {biblio_contributor_data} set drupal_uid = %d WHERE cid = %d ', $vsite->group->uid, $author['cid']);
            break(2);//We are done
          }
        }
      }
        
      //store external url title
      if (isset($node->biblio_url_title) && strlen($node->biblio_url_title)) {
        db_query('UPDATE {biblio} SET biblio_url_title = "%s" WHERE nid = %d', check_plain($node->biblio_url_title), $node->nid);
      }
      
    break;
    
    case 'validate':
      if ((int)$node->biblio_year == 0 && !_biblio_numeric_year($node->biblio_year)) {
        form_set_error('biblio_year', t('Invalid publication year'));
      }
        
      
    break;
      
      
    case 'view':
      //Files weight gets changed to 4 so lets put this before files
      $node->content['field_biblio_extra']['#weight'] = 3;

    break;
  }
}

/**
 * Define the scholar publication blocks with hook block
 */
function scholar_publications_block($op = 'list', $delta = false, $edit = array()) {
  if ($op == 'list') {
    $blocks['co_authors']['info'] = t('Co-Authors List');
    return $blocks;
  }
  elseif ($op == 'view') {
    switch ($delta) {
      case 'co_authors':
        return _scholar_publications_co_author_wgt();
    }
  }
}

/**
 * hook vsite_sidgets
 */
function scholar_publications_vsite_widgets(){
  $items = array();

  $items['scholar_publications-co_authors'] = array(
    'module' => 'scholar_publications',
    'delta' => 'co_authors',
    'weight' => 20,
    'region' => false,
    'tags' => array(
      'Content',
    ),
    'label' => 'Co-Authors List',
    'cache' => BLOCK_CACHE_CONTENT_CACHE,
    'cache_keys' => array(
      'node' => array('biblio' => 'biblio'),
      'os_og' => array('current' => 'current'),
    ),
  );
  return $items;
}

/**
 * Reduce duplicates in count queries for views
 *
 * @param object $view
 * @param string $query
 */
function scholar_publications_views_query_alter(&$view, &$query) {
  //dpm($view);
  if(in_array($view->name,array('publication_types','publication_years','publication_contributors')) && in_array($view->current_display,array('block_1','block_2')) && !isset($view->argument['name']->argument)){
    $query->fields['num_records']['distinct'] = true;
  }
}

/**
 * implementation of hook_views_pre_render
 * maps biblio years to their text values, submitted and in press.
 */
function scholar_publications_views_pre_render(&$view) {
  if ($view->name == 'publication_years') {
    foreach($view->result as $delta => $obj) {
      if ((int)$obj->biblio_biblio_year >= 9997) {
        $view->result[$delta]->link = _biblio_text_year($obj->biblio_biblio_year);
      }
    }
  }
}

/**
 * Scholar Publications biblio_entry theme
 */
function scholar_publications_theme(){
  return array(
    'scholar_publications_biblio_entry' => array(
        'file' => 'biblio_theme.inc',
        'arguments' => array(
          'node',
          'base' => 'biblio',
          'style_name' => 'classic',
          'inline' => FALSE,
          'wrapper' => TRUE),
    ),
  );
}

/**
 * hook theme_registry_alter
 */
function scholar_publications_theme_registry_alter(&$theme_registry){
  /*
   * Change the biblio theme to use ours so it can make the views consistent
   */
  $theme_registry['biblio_entry']['function'] = 'theme_scholar_publications_biblio_entry';
  $theme_registry['biblio_author_link']['function'] = 'scholar_publications_biblio_author_link';

  //Override the default node style function
  $theme_registry['biblio_tabular']['function'] = 'theme_scholar_publications_biblio_tabular';
  $theme_registry['biblio_tabular']['file'] = 'scholar_publications_biblio_tabular.tpl';
  $theme_registry['biblio_tabular']['path'] = drupal_get_path('module', 'scholar_publications')."/theme";
  $theme_registry['biblio_download_links']['function'] = 'scholar_publications_biblio_download_links';
  
  //Override publications by year box so biblio years display submitted/inpress/etc
  $theme_registry['views_view_summary__publication_years__block_1'] = $theme_registry['views_view_summary'];
  $theme_registry['views_view_summary__publication_years__block_1']['preprocess functions'][] = 'theme_scholar_publications_biblio_year_row';
}

/**
 * @function theme_scholar_publications_biblio_year_row
 *
 * Themes biblio years during preprocessing.  Changes the link title to the biblio year text,
 * but does not change the link to the numerical year.
 */
function theme_scholar_publications_biblio_year_row(&$vars) {
  foreach ($vars['rows']as $delta => $row) {
    if ((int)$row->link >= 9998) {
      $vars['rows'][$delta]->link = _biblio_text_year($row->link);
    }
  }
}

/**
 * Standardize the biblio entry look
 *
 * @param $node
 * @param $base
 * @param $style
 * @param $inline
 * @return unknown_type
 */
function theme_scholar_publications_biblio_entry($node, $base = 'biblio', $style = 'classic', $inline = false, $wrapper = true) {
  $s_output = "";

	if($wrapper) {
	  $s_output  .= "\n".'<div id="node-' . $node->nid . '" class="biblio-entry node node-teaser';
    if (!$node->status) $s_output .= ' node-unpublished';
    $s_output .='"><div class="node-inner">';

		//Add Vsite Admin links to entry
		if (module_exists('vsite_contextual')) {
  	  $links = vsite_contextual_get_admin_links('node', $node);
  	  if ($links) {
  	    $s_output .= '<div class="os-links">'.theme('ctools_dropdown', "Admin", $links , false, 'vsite-admin').'</div>';
  	  }
		}
  }

  $book_images = filefield_get_node_files($node, 'field_biblio_image');
  if (count($book_images)) {
  	$book_image = reset($book_images);
    $s_output .= '<div class="flL">' . l(theme('imagecache','book_cover_thumb', $book_image['filepath'],'','',NULL,FALSE), $node -> path, array('html' => TRUE)) . '</div>';
  }

  if (strlen($node->biblio_teaser_prefix)) {
    $s_output .= $node->biblio_teaser_prefix;
  }

  if (isset($node->content['teaser']['#prefix'])) {
    $s_output .= $node->content['teaser']['#prefix'];
  }//honor drupal prefix

  if($style == 'chicago' && in_array($node->biblio_type, array(1000)) && empty($node->biblio_publisher)){
    $node->biblio_publisher = "Working Paper";
  }//Note that this is a working paper after the title and before the year

  // first add the styled entry...
  $s_output .= theme('biblio_style', $node, $base, $style, $inline);

  // now add the various links
  if (strlen($node->biblio_abst_e)) $s_output .= l(" Abstract", "node/$node->nid",array('attributes'=>array('class' => 'biblio-abstract-link toggle')));

  $annotation_field = variable_get('biblio_annotations', 'none');
  if ($annotation_field != 'none' && $node-> $annotation_field) {
    $s_output .=  '<div class="biblio-annotation">' . check_markup($node->$annotation_field, $node->format, FALSE) . '</div>';
  }

  $openurl_base = variable_get('biblio_baseopenurl', '');
  if ($openurl_base) $s_output .= theme('biblio_openurl', biblio_openurl($node));

  // add links to attached files (if any) unless we have an image, then it would be crowded
  if (biblio_access('download', $node)) $s_output .= theme('biblio_download_links',$node);

  if( in_array($node->biblio_type, array(113,100,102,106,1001)) && strlen($node->biblio_url)){
    $url_title = (isset($node->biblio_url_title)) ? $node->biblio_url_title : 'Website';
    $s_output .= '<span class="teaser-extra">'. l($url_title, $node->biblio_url).'</span>';
  }//This is a software,data, article, book biblio entry, and it has a External URL

  if(variable_get('scholar_publications_note_in_teaser',false) && $node->biblio_notes)  $s_output .= '<span class="biblio-note">'. check_markup($node->biblio_notes, $node->format, FALSE) ."\n</span>";
  
  if (strlen($node->biblio_abst_e)) $s_output .= '<div class="biblio-abstract-display slider">'. $node->biblio_abst_e ."\n</div>";

  if (isset($node->content['teaser']['#suffix'])) {
    $s_output .= $node->content['teaser']['#suffix'];
  }//honor drupal suffix

  $links = module_invoke_all('link', 'node', $node, '');
  drupal_alter('link', $links, $node);
  $s_output .= '<div class="links links-inline">' . theme('links', $links) . '</div>';

  if($wrapper) $s_output .= "\n</div></div>";

  return $s_output;
}

/**
 * Override function for the biblio author links
 *
 * @param $author
 * @param $aid
 * @param $base
 * @param $inline
 * @return unknown_type
 */
function scholar_publications_biblio_author_link($author) {
  $db_result = db_query("SELECT n.nid as nid FROM {biblio_contributor_data} bcd INNER JOIN {node} n  ON n.uid = bcd.drupal_uid
                         WHERE n.type = 'vsite' AND bcd.cid = %d", $author['cid']);
  $a_node = db_fetch_array($db_result);
  $current_vsite = vsite_get_vsite();
	if(!$a_node || $current_vsite->group->nid == $a_node['nid']) return check_plain(trim($author['name'])); //Return if there is no vsite

	$vsite = vsite_get_vsite($a_node['nid']);

	$options = array('attributes' => array('target' => '_blank'),'purl' => array('provider' => $vsite->purl_provider, 'id' => $vsite->group->nid));
  $html = l(trim($author['name']), "publications", $options );

  return $html;
}

/**
 * Block information for the co-author widget
 * @return string
 */
function _scholar_publications_co_author_wgt(){
	$vsite = vsite_get_vsite();
  $result = db_query_range("SELECT bcd.name as name, COUNT(*) as num_site_publications, (SELECT COUNT(*) FROM {biblio_contributor_data} s_bcd INNER JOIN {biblio_contributor} s_bc ON s_bc.cid = s_bcd.cid WHERE s_bcd.cid = bcd.cid) as total_publications, bcd.drupal_uid as uid, bcd.cid as cid
                                     FROM {biblio_contributor_data} bcd
                                     INNER JOIN {biblio_contributor} bc ON bc.cid = bcd.cid
                                     INNER JOIN {og_ancestry} oa ON oa.nid = bc.nid
                                     WHERE oa.group_nid = %d AND (bcd.drupal_uid IS NULL OR bcd.drupal_uid != %d)
                                     GROUP BY bcd.cid ORDER BY lastname ASC  ", array($vsite->group->nid, $vsite->group->uid), 0, 10);
  $b_show = false;
  $output = "<ul class='co_authors'>";
  while ($data = db_fetch_object($result)) {
  	$b_show = true;
  	$owner_site = false;
  	$s_site_url = false;
  	if($data->uid){
  		$target_site = vsite_get_vsite_by_owner($data->uid);
  		if(count($target_site) && ($owner_site = array_shift($target_site))) $s_site_url = $owner_site->get_absolute_url('publications');
  	}

  	///////////////////////
  	//Simple Format
  	///////////////////////
    $output .= "\n<li>".($s_site_url?l($data->name,$s_site_url,array('attributes' => array("target" => "_blank"))):$data->name)."</li>";

  }
  $output .= "</ul>";

  return $b_show?array('subject' => "Co-Authors",'content' => $output):array();
}

/**
 * Return the citation without html
 * @param $node
 */
function _scholar_publications_get_plain_citation($node){
	$style = biblio_get_style();
  $base  = variable_get('biblio_base', 'biblio');

  if($style == 'chicago' && in_array($node->biblio_type, array(1000)) && empty($node->biblio_publisher)){
    $node->biblio_publisher = "Working Paper";
  }//Note that this is a working paper after the title and before the year



  $citation = theme('biblio_style', $node, $base, $style);

	//add url to citation
	if (function_exists('shorten_url') && variable_get('scholar_publications_shorten_citations', 0)) {
		global $base_url;

		/* replace punctuation at end of citaiton with period.  biblio_coins follow end of citation and block an easy RE match, so we're appending them. */

    $coins = filter_xss($node->biblio_coins, array('span'));
    $re = '/' .  '[!-~] (<\/\w*>)?' . preg_quote($coins, '/') . '/';

    if (preg_match( $re, $citation)) {
      $citation = preg_replace($re, ", </span>$coins", $citation);
    }

		$citation .= ' copy at ' . shorten_url(url('node/'.$node->nid, array('absolute'=>TRUE)));
	}

  $citation = strip_tags($citation);
/*
  $pattern = '|<[^>]+>(.*)</[^>]+>|U';
  $body = $node->content['body']['#value'];
  preg_match_all($pattern, $body, $matches, PREG_SET_ORDER | PREG_OFFSET_CAPTURE);

  $data = array();
  foreach ($matches as $k => $m) {
    if (empty($m[0][0])) continue;
    if (strlen(strip_tags($m[0][0])) == 0) continue;

    $new_d = array();
    $end = 0;
    if (isset($matches[$k+1])) {
      $end = $matches[$k+1][0][1] - $m[0][1];
    }
    else {
      $end = strlen($body) - 6 - $m[0][1];
    }
    $new_d['html'] = substr($body, $m[0][1], $end);
    $new_d['text'] = strip_tags($new_d['html']);
    $new_d['inside'] = $m[1][0];
    $new_d['outside'] = str_replace(array($m[0][0], chr(226).chr(128).chr(147)), array('','-'), $new_d['html']);
    $data[] = $new_d;
  }

  foreach ($data as $d) {
    if (@strpos($citation, $d['text']) !== FALSE || @strpos($citation, $d['outside']) !== FALSE || @strpos($citation, $d['inside']) !== FALSE) {
      $node->content['body']['#value'] = str_replace($d['html'], '', $node->content['body']['#value']);
     // var_dump( $node->content['body']['#value']);
    }
  }
*/
  drupal_add_js('function selectText(ele) {
	try {
  	var div = document.createRange();
    div.setStartBefore(ele);
    div.setEndAfter(ele) ;
  	window.getSelection().addRange(div);
  }
  catch (e) {
  	// we\'re in internet explorer
  	div = document.selection.createRange();
  	div.moveToElementText(ele);
  	div.select();
  }
}','inline');
  $citation = "<dl><dt>Citation:</dt><dd class=\"biblio-citation\" onclick=\"if (event.target) selectText(event.target); else selectText(this);\">{$citation}</dd></dl>";
  $citation .= _scholar_publications_export_link($node);

  return $citation;
}


/**
 * hook link_alter
 * modify the export links to use ctools
 */
function scholar_publications_link_alter(&$links, $node){
	//Remove biblio export links
	foreach ($links as $key => $value){
		if(substr($key,0,7) == "biblio_") unset($links[$key]);
	}
}

/**
 * Implementation of hook_link().
 *
 * This is implemented so that an export links are displayed
 */
function _scholar_publications_export_link($node) {
  $links = array();
  $parent = '';
  $base = variable_get('biblio_base', 'biblio');

  if ($node->type == 'biblio') {
    if(biblio_access('export', $node)){
	    $links = array();
	    $show_link = variable_get('biblio_export_links', array('rtf' => TRUE,'tagged' => TRUE, 'xml' => TRUE, 'bibtex' => TRUE));
	    $show_link['google'] = variable_get('biblio_google_link', 1);
	    if ($show_link['rtf'])    $links['biblio_rtf']            = _build_biblio_rtf_link($base, $node->nid);
	    if ($show_link['tagged']) $links['biblio_tagged']         = _build_biblio_tagged_link($base, $node->nid);
	    if ($show_link['xml'])    $links['biblio_xml']            = _build_biblio_xml_link($base, $node->nid);
	    if ($show_link['bibtex']) $links['biblio_bibtex']         = _build_biblio_bibtex_link($base, $node->nid);
	    if ($show_link['google']) $links['biblio_google_scholar'] = _build_google_scholar_link($node);
	    $parent = theme('ctools_dropdown', t('Export'), $links, false,'biblio-export');
	  }
  }

  return $parent;
}



function scholar_publications_biblio_download_links($node = NULL) {
  $files = '';
  if (!empty ($node->files) && count($node->files) > 0 && user_access('view uploaded files')) {
    $files .= '<span class="biblio_file_links">';
    //$files .= '&nbsp;'. t('Download') .':&nbsp;';
    $file_count = 0;
    foreach ($node->files as $file) {
      if(!is_object($file)) $file = (object) $file;
      if ($file->list) {
        $file_count++;

        // add icon for this file extension.  remove extra itweak_upload stylings
        $extension = strtolower(substr(strrchr($file->filename, '.'), 1));
        $class = 'mime itu-insert-file mime-' . $extension;
        
        $alias = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s'",'filefield_paths/alias/' . $file -> fid));
        $href = ($alias) ?  $alias : file_create_url($file->filepath);
        $text = $file->description ? $file->description : $file->filename;
        //$files .= l($text, $href) .'&nbsp;('. format_size($file->filesize).')';
        $files .= '<span class="teaser-extra">'.l($text, $href,array('attributes'=>array('class'=>$class . ' download-file download-file-' . $text))).'</span>';
      }
    }
    $files .= '</span>';
  }
  if (module_exists('filefield')) { // now lets get any CCK FileField files...
    $fields = filefield_get_field_list('biblio');
    foreach ($fields as $field_name => $field) {
      if($field_name == 'field_biblio_image') continue; //Do not re-display this in the teaser

      if (filefield_view_access($field_name, $node)) {
        $field_files = filefield_get_node_files($node, $field_name);
        if ($field_files) {
          foreach ($field_files as $file) {
            if ($file['fid']) {
              $files .= '<span class="teaser-extra">'. theme('filefield_file', $file) .'</span>';
            }
          }
        }
      }
    }
  }

  return $files;
}

function scholar_publications_export($format = "tagged", $nid = null, $popup = false, $version = 8) {
	$vsite = vsite_get_vsite();

	$title = 'publications';
	if ($nid !== null) {
		$node = node_load($nid);
		$title = str_replace(' ', '_', $node->title);
		$title = substr($title, 0, 8);
	}elseif (empty($_SESSION['last_biblio_query'])){
		//Biblio uses this session value, if this is an anon user that has no session (or a cli user) lets set this up for them
		$a_args = array();
		if (($a_filtered_pubtypes = variable_get('scholar_publications_filter_publication_types',array())) && count($a_filtered_pubtypes)){
	    if($a_filtered_pubtypes != array_keys(scholar_publications_get_biblio_types())){
	      //Filter pulications to those requested, if they do not have all pub types selected
	      $a_args = array('type',$a_filtered_pubtypes);
	    }
	  }
	  //Setup the default query
	  module_load_include('inc', 'biblio', 'biblio.pages');
	  biblio_build_query($a_args);
	}

	require_once(drupal_get_path('module','biblio').'/biblio.import.export.inc');
	ob_start();
	$output = biblio_export($format, $nid, $popup, $version);
	if (empty($output)) {
		// the export didn't return anything, which means it output directly to the browser
		$output = ob_get_clean();
		// get site owner's name
		$owner_name = $vsite->group->name;
		switch ($format) {
			case 'tagged':
        drupal_set_header('Content-Disposition:  filename="'.$owner_name.'-'.$title.'-tagged.enw"');
			break;
			case 'xml':
			case 'endnote8':
				drupal_set_header('Content-Disposition: attachment; filename="'.$owner_name.'-'.$title.'.xml"');
			break;
			case 'bibtex':
				drupal_set_header('Content-Disposition:  filename="'.$owner_name.'-'.$title.'-Bibtex.bib"');
			break;
			case 'csv':
        drupal_set_header('Content-Disposition: attachment; filename="'.$owner_name.'-'.$title.'-export.csv"');
			break;
		}
    echo $output;
	}
  else {
    ob_end_clean();
    return $output;
	}
}

function scholar_publications_preprocess_page(&$vars) {
  if (strpos($_GET['q'], 'type') !== FALSE) {
    $vars['title'] = drupal_get_title();
  }
}

/**
 * implementation of hook_views_pre_view()
 */
function scholar_publications_views_pre_view(&$view) {
  if ($view->name == "publication_types") {
    $sorts = $view->display['default']->display_options['sorts'];
    $newsorts = array(
      'biblio_year' => array (
        'order' => 'DESC',
        'id' => 'biblio_year',
        'table' => 'biblio',
        'field' => 'biblio_year',
        'relationship' => 'none',
      ),
     );
    $view->display_handler->set_option('sorts', array_merge($newsorts, $sorts));
  }
}

/**
 * implementation of hook_views_post_render()
 */
function scholar_publications_views_post_render($view, $output, $cache){
  if($view->name == "publication_types" && $view->current_display == "page_1"){
    //Make the page title plural
    if(isset($view->argument['name'])){
    	drupal_set_title( scholar_publications_get_plural_biblio_type( $view->argument['name']->get_title() ));
    }
  }
}

/**
 * Return the avalible bilbio publication types
 *
 * @param $reset
 */
function scholar_publications_get_biblio_types($reset = FALSE){
	static $types;
	
	if($reset || !isset($types)){
		$types = array();
		
	  $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE tid > -1 AND visible = 1');
	  while ($option = db_fetch_object($result)) {
	    $types[$option->tid] = _biblio_localize_type($option->tid, $option->name);
	  }
	}
	
	return $types;
}

/**
 * Return the plural version of a  bilbio publication type
 *
 * @param $s_type
 */
function scholar_publications_get_plural_biblio_type($s_type){
	
	$a_add_s = array("book","book chapter","journal article","conference paper","newspaper article","magazine article","web article","report","film","broadcast","artwork","hearing","case","bill","statute","patent","manuscript","map","chart","database","government report","legal ruling","miscellaneous section","working paper");
	$a_replace = array( "thesis" => "Theses", "unpublished" => "Unpublished Publications" );
	
	if(is_numeric($s_type)){
	  	$a_all_types = scholar_publications_get_biblio_types();
	  	
	  	if(isset($a_all_types[$s_type])){
	     $s_type = $a_all_types[$s_type];
	  	}
	}
	
	if(in_array(strtolower($s_type),$a_add_s)){
		return $s_type."s";
	}
	
  if(isset($a_replace[strtolower($s_type)])){
    return $a_replace[strtolower($s_type)];
  }
	
	return $s_type;
}